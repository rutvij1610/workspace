package sedya.data;

import ducks.driver.SeDyANodes;
import java.util.Collection;

/**
 * In reality, AggregateSignatures are not distinguishable from normal Signatures.
 * However, in this simulation we do not use real cryptography, so we need this
 * in order to restrict the verification.
 * Verification occurs based on the sum of all the identities.
 * This is, of course, not a cryptographically secure method, but it is
 * sufficient to check that the provided set matches the one from which this
 * aggregate signature is generated. It is order insensitive, but duplicate
 * sensitive, which is exactly how the real method would work.
*/
public class AggregateSignature extends AbstractSignature implements Cloneable {

    protected final long val;

    /**
     * Generate an aggregate signature with initial identities ids.
     * @param ids the identities.
     */
    public AggregateSignature(Collection<Identity> ids) {
        long r = 0;
        for (Identity id : ids) {
            r += id.get();
        }
        val = r;
    }

    /**
     * Generate an aggregate signature with initial identities ids.
     * @param ids the identities.
     */
    public AggregateSignature(Identity id) {
        val = id.get();
    }

    /** Generate an aggregate signature with given value v.
     * This is <b>only</b> used for aggregating different aggregate signatures
     * and for defining empty signatures.
     * @param v the value.
     */
    protected AggregateSignature(long v) {
        val = v;
    }

    /**
     * Aggregates the given signature with this one.
     * Neither instance will be modified; a new AggregateSignature instance
     * will be created.
     * @param sig the other signature
     */
    public AggregateSignature addSignature(AggregateSignature sig) {
        return new AggregateSignature(val + sig.val);
    }

    /**
     * Checks this signature.
     */
    @Override
    protected boolean checkSignature(Identity id) {
        return val == id.get();
    }

    /**
     * Checks the signature with the given collection of identities.
     * This check is order insensitive but duplicate sensitive.
     * @param ids the identities.
     * @return true if the signature was generated by the given multiset of ids
     */
    @Override
    protected boolean checkSignature(Collection<Identity> ids) {
        long v = 0;
        for (Identity id : ids) {
            v += id.get();
        }
        return v == this.val;
    }

    @Override
    public AggregateSignature clone() {
        return new AggregateSignature(this.val);
    }

    @Override
    public String toString(){
        return ""+this.val;
    }
}
